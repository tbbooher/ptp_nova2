// google analytics
!function(e, t, n, a, i, s, o) {
    e.GoogleAnalyticsObject = i, e[i] = e[i] || function() {
        (e[i].q = e[i].q || []).push(arguments);
    }, e[i].l = 1 * new Date(), s = t.createElement(n), o = t.getElementsByTagName(n)[0], 
    s.async = 1, s.src = a, o.parentNode.insertBefore(s, o);
}(window, document, "script", "//www.google-analytics.com/analytics.js", "ga"), 
ga("create", "UA-40651058-1", "ptpnova.com"), ga("send", "pageview"), function(e) {
    //FlexSlider: Object Instance
    e.flexslider = function(t, n) {
        var a = e(t);
        // making variables public
        a.vars = e.extend({}, e.flexslider.defaults, n);
        var i, s = a.vars.namespace, o = window.navigator && window.navigator.msPointerEnabled && window.MSGesture, r = ("ontouchstart" in window || o || window.DocumentTouch && document instanceof DocumentTouch) && a.vars.touch, // depricating this idea, as devices are being released with both of these events
        //eventType = (touch) ? "touchend" : "click",
        l = "click touchend MSPointerUp", c = "", u = "vertical" === a.vars.direction, d = a.vars.reverse, v = a.vars.itemWidth > 0, p = "fade" === a.vars.animation, m = "" !== a.vars.asNavFor, h = {}, f = !0;
        // Store a reference to the slider object
        e.data(t, "flexslider", a), // Private slider methods
        h = {
            init:function() {
                a.animating = !1, // Get current slide and make sure it is a number
                a.currentSlide = parseInt(a.vars.startAt ? a.vars.startAt :0), isNaN(a.currentSlide) && (a.currentSlide = 0), 
                a.animatingTo = a.currentSlide, a.atEnd = 0 === a.currentSlide || a.currentSlide === a.last, 
                a.containerSelector = a.vars.selector.substr(0, a.vars.selector.search(" ")), a.slides = e(a.vars.selector, a), 
                a.container = e(a.containerSelector, a), a.count = a.slides.length, // SYNC:
                a.syncExists = e(a.vars.sync).length > 0, // SLIDE:
                "slide" === a.vars.animation && (a.vars.animation = "swing"), a.prop = u ? "top" :"marginLeft", 
                a.args = {}, // SLIDESHOW:
                a.manualPause = !1, a.stopped = !1, //PAUSE WHEN INVISIBLE
                a.started = !1, a.startTimeout = null, // TOUCH/USECSS:
                a.transitions = !a.vars.video && !p && a.vars.useCSS && function() {
                    var e = document.createElement("div"), t = [ "perspectiveProperty", "WebkitPerspective", "MozPerspective", "OPerspective", "msPerspective" ];
                    for (var n in t) if (void 0 !== e.style[t[n]]) return a.pfx = t[n].replace("Perspective", "").toLowerCase(), 
                    a.prop = "-" + a.pfx + "-transform", !0;
                    return !1;
                }(), // CONTROLSCONTAINER:
                "" !== a.vars.controlsContainer && (a.controlsContainer = e(a.vars.controlsContainer).length > 0 && e(a.vars.controlsContainer)), 
                // MANUAL:
                "" !== a.vars.manualControls && (a.manualControls = e(a.vars.manualControls).length > 0 && e(a.vars.manualControls)), 
                // RANDOMIZE:
                a.vars.randomize && (a.slides.sort(function() {
                    return Math.round(Math.random()) - .5;
                }), a.container.empty().append(a.slides)), a.doMath(), // INIT
                a.setup("init"), // CONTROLNAV:
                a.vars.controlNav && h.controlNav.setup(), // DIRECTIONNAV:
                a.vars.directionNav && h.directionNav.setup(), // KEYBOARD:
                a.vars.keyboard && (1 === e(a.containerSelector).length || a.vars.multipleKeyboard) && e(document).bind("keyup", function(e) {
                    var t = e.keyCode;
                    if (!a.animating && (39 === t || 37 === t)) {
                        var n = 39 === t ? a.getTarget("next") :37 === t ? a.getTarget("prev") :!1;
                        a.flexAnimate(n, a.vars.pauseOnAction);
                    }
                }), // MOUSEWHEEL:
                a.vars.mousewheel && a.bind("mousewheel", function(e, t) {
                    e.preventDefault();
                    var n = 0 > t ? a.getTarget("next") :a.getTarget("prev");
                    a.flexAnimate(n, a.vars.pauseOnAction);
                }), // PAUSEPLAY
                a.vars.pausePlay && h.pausePlay.setup(), //PAUSE WHEN INVISIBLE
                a.vars.slideshow && a.vars.pauseInvisible && h.pauseInvisible.init(), // SLIDSESHOW
                a.vars.slideshow && (a.vars.pauseOnHover && a.hover(function() {
                    a.manualPlay || a.manualPause || a.pause();
                }, function() {
                    a.manualPause || a.manualPlay || a.stopped || a.play();
                }), // initialize animation
                //If we're visible, or we don't use PageVisibility API
                a.vars.pauseInvisible && h.pauseInvisible.isHidden() || (a.vars.initDelay > 0 ? a.startTimeout = setTimeout(a.play, a.vars.initDelay) :a.play())), 
                // ASNAV:
                m && h.asNav.setup(), // TOUCH
                r && a.vars.touch && h.touch(), // FADE&&SMOOTHHEIGHT || SLIDE:
                (!p || p && a.vars.smoothHeight) && e(window).bind("resize orientationchange focus", h.resize), 
                a.find("img").attr("draggable", "false"), // API: start() Callback
                setTimeout(function() {
                    a.vars.start(a);
                }, 200);
            },
            asNav:{
                setup:function() {
                    a.asNav = !0, a.animatingTo = Math.floor(a.currentSlide / a.move), a.currentItem = a.currentSlide, 
                    a.slides.removeClass(s + "active-slide").eq(a.currentItem).addClass(s + "active-slide"), 
                    o ? (t._slider = a, a.slides.each(function() {
                        var t = this;
                        t._gesture = new MSGesture(), t._gesture.target = t, t.addEventListener("MSPointerDown", function(e) {
                            e.preventDefault(), e.currentTarget._gesture && e.currentTarget._gesture.addPointer(e.pointerId);
                        }, !1), t.addEventListener("MSGestureTap", function(t) {
                            t.preventDefault();
                            var n = e(this), i = n.index();
                            e(a.vars.asNavFor).data("flexslider").animating || n.hasClass("active") || (a.direction = a.currentItem < i ? "next" :"prev", 
                            a.flexAnimate(i, a.vars.pauseOnAction, !1, !0, !0));
                        });
                    })) :a.slides.click(function(t) {
                        t.preventDefault();
                        var n = e(this), i = n.index(), o = n.offset().left - e(a).scrollLeft();
                        // Find position of slide relative to left of slider container
                        0 >= o && n.hasClass(s + "active-slide") ? a.flexAnimate(a.getTarget("prev"), !0) :e(a.vars.asNavFor).data("flexslider").animating || n.hasClass(s + "active-slide") || (a.direction = a.currentItem < i ? "next" :"prev", 
                        a.flexAnimate(i, a.vars.pauseOnAction, !1, !0, !0));
                    });
                }
            },
            controlNav:{
                setup:function() {
                    a.manualControls ? // MANUALCONTROLS:
                    h.controlNav.setupManual() :h.controlNav.setupPaging();
                },
                setupPaging:function() {
                    var t, n, i = "thumbnails" === a.vars.controlNav ? "control-thumbs" :"control-paging", o = 1;
                    if (a.controlNavScaffold = e('<ol class="' + s + "control-nav " + s + i + '"></ol>'), 
                    a.pagingCount > 1) for (var r = 0; r < a.pagingCount; r++) {
                        if (n = a.slides.eq(r), t = "thumbnails" === a.vars.controlNav ? '<img src="' + n.attr("data-thumb") + '"/>' :"<a>" + o + "</a>", 
                        "thumbnails" === a.vars.controlNav && !0 === a.vars.thumbCaptions) {
                            var u = n.attr("data-thumbcaption");
                            "" != u && void 0 != u && (t += '<span class="' + s + 'caption">' + u + "</span>");
                        }
                        a.controlNavScaffold.append("<li>" + t + "</li>"), o++;
                    }
                    // CONTROLSCONTAINER:
                    a.controlsContainer ? e(a.controlsContainer).append(a.controlNavScaffold) :a.append(a.controlNavScaffold), 
                    h.controlNav.set(), h.controlNav.active(), a.controlNavScaffold.delegate("a, img", l, function(t) {
                        if (t.preventDefault(), "" === c || c === t.type) {
                            var n = e(this), i = a.controlNav.index(n);
                            n.hasClass(s + "active") || (a.direction = i > a.currentSlide ? "next" :"prev", 
                            a.flexAnimate(i, a.vars.pauseOnAction));
                        }
                        // setup flags to prevent event duplication
                        "" === c && (c = t.type), h.setToClearWatchedEvent();
                    });
                },
                setupManual:function() {
                    a.controlNav = a.manualControls, h.controlNav.active(), a.controlNav.bind(l, function(t) {
                        if (t.preventDefault(), "" === c || c === t.type) {
                            var n = e(this), i = a.controlNav.index(n);
                            n.hasClass(s + "active") || (a.direction = i > a.currentSlide ? "next" :"prev", 
                            a.flexAnimate(i, a.vars.pauseOnAction));
                        }
                        // setup flags to prevent event duplication
                        "" === c && (c = t.type), h.setToClearWatchedEvent();
                    });
                },
                set:function() {
                    var t = "thumbnails" === a.vars.controlNav ? "img" :"a";
                    a.controlNav = e("." + s + "control-nav li " + t, a.controlsContainer ? a.controlsContainer :a);
                },
                active:function() {
                    a.controlNav.removeClass(s + "active").eq(a.animatingTo).addClass(s + "active");
                },
                update:function(t, n) {
                    a.pagingCount > 1 && "add" === t ? a.controlNavScaffold.append(e("<li><a>" + a.count + "</a></li>")) :1 === a.pagingCount ? a.controlNavScaffold.find("li").remove() :a.controlNav.eq(n).closest("li").remove(), 
                    h.controlNav.set(), a.pagingCount > 1 && a.pagingCount !== a.controlNav.length ? a.update(n, t) :h.controlNav.active();
                }
            },
            directionNav:{
                setup:function() {
                    var t = e('<ul class="' + s + 'direction-nav"><li><a class="' + s + 'prev" href="#">' + a.vars.prevText + '</a></li><li><a class="' + s + 'next" href="#">' + a.vars.nextText + "</a></li></ul>");
                    // CONTROLSCONTAINER:
                    a.controlsContainer ? (e(a.controlsContainer).append(t), a.directionNav = e("." + s + "direction-nav li a", a.controlsContainer)) :(a.append(t), 
                    a.directionNav = e("." + s + "direction-nav li a", a)), h.directionNav.update(), 
                    a.directionNav.bind(l, function(t) {
                        t.preventDefault();
                        var n;
                        ("" === c || c === t.type) && (n = e(this).hasClass(s + "next") ? a.getTarget("next") :a.getTarget("prev"), 
                        a.flexAnimate(n, a.vars.pauseOnAction)), // setup flags to prevent event duplication
                        "" === c && (c = t.type), h.setToClearWatchedEvent();
                    });
                },
                update:function() {
                    var e = s + "disabled";
                    1 === a.pagingCount ? a.directionNav.addClass(e).attr("tabindex", "-1") :a.vars.animationLoop ? a.directionNav.removeClass(e).removeAttr("tabindex") :0 === a.animatingTo ? a.directionNav.removeClass(e).filter("." + s + "prev").addClass(e).attr("tabindex", "-1") :a.animatingTo === a.last ? a.directionNav.removeClass(e).filter("." + s + "next").addClass(e).attr("tabindex", "-1") :a.directionNav.removeClass(e).removeAttr("tabindex");
                }
            },
            pausePlay:{
                setup:function() {
                    var t = e('<div class="' + s + 'pauseplay"><a></a></div>');
                    // CONTROLSCONTAINER:
                    a.controlsContainer ? (a.controlsContainer.append(t), a.pausePlay = e("." + s + "pauseplay a", a.controlsContainer)) :(a.append(t), 
                    a.pausePlay = e("." + s + "pauseplay a", a)), h.pausePlay.update(a.vars.slideshow ? s + "pause" :s + "play"), 
                    a.pausePlay.bind(l, function(t) {
                        t.preventDefault(), ("" === c || c === t.type) && (e(this).hasClass(s + "pause") ? (a.manualPause = !0, 
                        a.manualPlay = !1, a.pause()) :(a.manualPause = !1, a.manualPlay = !0, a.play())), 
                        // setup flags to prevent event duplication
                        "" === c && (c = t.type), h.setToClearWatchedEvent();
                    });
                },
                update:function(e) {
                    "play" === e ? a.pausePlay.removeClass(s + "pause").addClass(s + "play").html(a.vars.playText) :a.pausePlay.removeClass(s + "play").addClass(s + "pause").html(a.vars.pauseText);
                }
            },
            touch:function() {
                function e(e) {
                    a.animating ? e.preventDefault() :(window.navigator.msPointerEnabled || 1 === e.touches.length) && (a.pause(), 
                    // CAROUSEL:
                    f = u ? a.h :a.w, y = Number(new Date()), // CAROUSEL:
                    // Local vars for X and Y points.
                    S = e.touches[0].pageX, b = e.touches[0].pageY, h = v && d && a.animatingTo === a.last ? 0 :v && d ? a.limit - (a.itemW + a.vars.itemMargin) * a.move * a.animatingTo :v && a.currentSlide === a.last ? a.limit :v ? (a.itemW + a.vars.itemMargin) * a.move * a.currentSlide :d ? (a.last - a.currentSlide + a.cloneOffset) * f :(a.currentSlide + a.cloneOffset) * f, 
                    c = u ? b :S, m = u ? S :b, t.addEventListener("touchmove", n, !1), t.addEventListener("touchend", i, !1));
                }
                function n(e) {
                    // Local vars for X and Y points.
                    S = e.touches[0].pageX, b = e.touches[0].pageY, g = u ? c - b :c - S, w = u ? Math.abs(g) < Math.abs(S - m) :Math.abs(g) < Math.abs(b - m);
                    var t = 500;
                    (!w || Number(new Date()) - y > t) && (e.preventDefault(), !p && a.transitions && (a.vars.animationLoop || (g /= 0 === a.currentSlide && 0 > g || a.currentSlide === a.last && g > 0 ? Math.abs(g) / f + 2 :1), 
                    a.setProps(h + g, "setTouch")));
                }
                function i() {
                    if (// finish the touch by undoing the touch session
                    t.removeEventListener("touchmove", n, !1), a.animatingTo === a.currentSlide && !w && null !== g) {
                        var e = d ? -g :g, s = e > 0 ? a.getTarget("next") :a.getTarget("prev");
                        a.canAdvance(s) && (Number(new Date()) - y < 550 && Math.abs(e) > 50 || Math.abs(e) > f / 2) ? a.flexAnimate(s, a.vars.pauseOnAction) :p || a.flexAnimate(a.currentSlide, a.vars.pauseOnAction, !0);
                    }
                    t.removeEventListener("touchend", i, !1), c = null, m = null, g = null, h = null;
                }
                function s(e) {
                    e.stopPropagation(), a.animating ? e.preventDefault() :(a.pause(), t._gesture.addPointer(e.pointerId), 
                    T = 0, f = u ? a.h :a.w, y = Number(new Date()), // CAROUSEL:
                    h = v && d && a.animatingTo === a.last ? 0 :v && d ? a.limit - (a.itemW + a.vars.itemMargin) * a.move * a.animatingTo :v && a.currentSlide === a.last ? a.limit :v ? (a.itemW + a.vars.itemMargin) * a.move * a.currentSlide :d ? (a.last - a.currentSlide + a.cloneOffset) * f :(a.currentSlide + a.cloneOffset) * f);
                }
                function r(e) {
                    e.stopPropagation();
                    var n = e.target._slider;
                    if (n) {
                        var a = -e.translationX, i = -e.translationY;
                        //Accumulate translations.
                        return T += u ? i :a, g = T, w = u ? Math.abs(T) < Math.abs(-a) :Math.abs(T) < Math.abs(-i), 
                        e.detail === e.MSGESTURE_FLAG_INERTIA ? (setImmediate(function() {
                            t._gesture.stop();
                        }), void 0) :((!w || Number(new Date()) - y > 500) && (e.preventDefault(), !p && n.transitions && (n.vars.animationLoop || (g = T / (0 === n.currentSlide && 0 > T || n.currentSlide === n.last && T > 0 ? Math.abs(T) / f + 2 :1)), 
                        n.setProps(h + g, "setTouch"))), void 0);
                    }
                }
                function l(e) {
                    e.stopPropagation();
                    var t = e.target._slider;
                    if (t) {
                        if (t.animatingTo === t.currentSlide && !w && null !== g) {
                            var n = d ? -g :g, a = n > 0 ? t.getTarget("next") :t.getTarget("prev");
                            t.canAdvance(a) && (Number(new Date()) - y < 550 && Math.abs(n) > 50 || Math.abs(n) > f / 2) ? t.flexAnimate(a, t.vars.pauseOnAction) :p || t.flexAnimate(t.currentSlide, t.vars.pauseOnAction, !0);
                        }
                        c = null, m = null, g = null, h = null, T = 0;
                    }
                }
                var c, m, h, f, g, y, w = !1, S = 0, b = 0, T = 0;
                o ? (t.style.msTouchAction = "none", t._gesture = new MSGesture(), t._gesture.target = t, 
                t.addEventListener("MSPointerDown", s, !1), t._slider = a, t.addEventListener("MSGestureChange", r, !1), 
                t.addEventListener("MSGestureEnd", l, !1)) :t.addEventListener("touchstart", e, !1);
            },
            resize:function() {
                !a.animating && a.is(":visible") && (v || a.doMath(), p ? // SMOOTH HEIGHT:
                h.smoothHeight() :v ? (//CAROUSEL:
                a.slides.width(a.computedW), a.update(a.pagingCount), a.setProps()) :u ? (//VERTICAL:
                a.viewport.height(a.h), a.setProps(a.h, "setTotal")) :(// SMOOTH HEIGHT:
                a.vars.smoothHeight && h.smoothHeight(), a.newSlides.width(a.computedW), a.setProps(a.computedW, "setTotal")));
            },
            smoothHeight:function(e) {
                if (!u || p) {
                    var t = p ? a :a.viewport;
                    e ? t.animate({
                        height:a.slides.eq(a.animatingTo).height()
                    }, e) :t.height(a.slides.eq(a.animatingTo).height());
                }
            },
            sync:function(t) {
                var n = e(a.vars.sync).data("flexslider"), i = a.animatingTo;
                switch (t) {
                  case "animate":
                    n.flexAnimate(i, a.vars.pauseOnAction, !1, !0);
                    break;

                  case "play":
                    n.playing || n.asNav || n.play();
                    break;

                  case "pause":
                    n.pause();
                }
            },
            pauseInvisible:{
                visProp:null,
                init:function() {
                    var e = [ "webkit", "moz", "ms", "o" ];
                    if ("hidden" in document) return "hidden";
                    for (var t = 0; t < e.length; t++) e[t] + "Hidden" in document && (h.pauseInvisible.visProp = e[t] + "Hidden");
                    if (h.pauseInvisible.visProp) {
                        var n = h.pauseInvisible.visProp.replace(/[H|h]idden/, "") + "visibilitychange";
                        document.addEventListener(n, function() {
                            h.pauseInvisible.isHidden() ? a.startTimeout ? clearTimeout(a.startTimeout) :a.pause() :a.started ? a.play() :a.vars.initDelay > 0 ? setTimeout(a.play, a.vars.initDelay) :a.play();
                        });
                    }
                },
                isHidden:function() {
                    return document[h.pauseInvisible.visProp] || !1;
                }
            },
            setToClearWatchedEvent:function() {
                clearTimeout(i), i = setTimeout(function() {
                    c = "";
                }, 3e3);
            }
        }, // public methods
        a.flexAnimate = function(t, n, i, o, l) {
            if (a.vars.animationLoop || t === a.currentSlide || (a.direction = t > a.currentSlide ? "next" :"prev"), 
            m && 1 === a.pagingCount && (a.direction = a.currentItem < t ? "next" :"prev"), 
            !a.animating && (a.canAdvance(t, l) || i) && a.is(":visible")) {
                if (m && o) {
                    var c = e(a.vars.asNavFor).data("flexslider");
                    if (a.atEnd = 0 === t || t === a.count - 1, c.flexAnimate(t, !0, !1, !0, l), a.direction = a.currentItem < t ? "next" :"prev", 
                    c.direction = a.direction, Math.ceil((t + 1) / a.visible) - 1 === a.currentSlide || 0 === t) return a.currentItem = t, 
                    a.slides.removeClass(s + "active-slide").eq(t).addClass(s + "active-slide"), !1;
                    a.currentItem = t, a.slides.removeClass(s + "active-slide").eq(t).addClass(s + "active-slide"), 
                    t = Math.floor(t / a.visible);
                }
                // SLIDE:
                if (a.animating = !0, a.animatingTo = t, // SLIDESHOW:
                n && a.pause(), // API: before() animation Callback
                a.vars.before(a), // SYNC:
                a.syncExists && !l && h.sync("animate"), // CONTROLNAV
                a.vars.controlNav && h.controlNav.active(), // !CAROUSEL:
                // CANDIDATE: slide active class (for add/remove slide)
                v || a.slides.removeClass(s + "active-slide").eq(t).addClass(s + "active-slide"), 
                // INFINITE LOOP:
                // CANDIDATE: atEnd
                a.atEnd = 0 === t || t === a.last, // DIRECTIONNAV:
                a.vars.directionNav && h.directionNav.update(), t === a.last && (// API: end() of cycle Callback
                a.vars.end(a), // SLIDESHOW && !INFINITE LOOP:
                a.vars.animationLoop || a.pause()), p) // FADE:
                r ? (a.slides.eq(a.currentSlide).css({
                    opacity:0,
                    zIndex:1
                }), a.slides.eq(t).css({
                    opacity:1,
                    zIndex:2
                }), a.wrapup(w)) :(//slider.slides.eq(slider.currentSlide).fadeOut(slider.vars.animationSpeed, slider.vars.easing);
                //slider.slides.eq(target).fadeIn(slider.vars.animationSpeed, slider.vars.easing, slider.wrapup);
                a.slides.eq(a.currentSlide).css({
                    zIndex:1
                }).animate({
                    opacity:0
                }, a.vars.animationSpeed, a.vars.easing), a.slides.eq(t).css({
                    zIndex:2
                }).animate({
                    opacity:1
                }, a.vars.animationSpeed, a.vars.easing, a.wrapup)); else {
                    var f, g, y, w = u ? a.slides.filter(":first").height() :a.computedW;
                    // INFINITE LOOP / REVERSE:
                    v ? (//margin = (slider.vars.itemWidth > slider.w) ? slider.vars.itemMargin * 2 : slider.vars.itemMargin;
                    f = a.vars.itemMargin, y = (a.itemW + f) * a.move * a.animatingTo, g = y > a.limit && 1 !== a.visible ? a.limit :y) :g = 0 === a.currentSlide && t === a.count - 1 && a.vars.animationLoop && "next" !== a.direction ? d ? (a.count + a.cloneOffset) * w :0 :a.currentSlide === a.last && 0 === t && a.vars.animationLoop && "prev" !== a.direction ? d ? 0 :(a.count + 1) * w :d ? (a.count - 1 - t + a.cloneOffset) * w :(t + a.cloneOffset) * w, 
                    a.setProps(g, "", a.vars.animationSpeed), a.transitions ? (a.vars.animationLoop && a.atEnd || (a.animating = !1, 
                    a.currentSlide = a.animatingTo), a.container.unbind("webkitTransitionEnd transitionend"), 
                    a.container.bind("webkitTransitionEnd transitionend", function() {
                        a.wrapup(w);
                    })) :a.container.animate(a.args, a.vars.animationSpeed, a.vars.easing, function() {
                        a.wrapup(w);
                    });
                }
                // SMOOTH HEIGHT:
                a.vars.smoothHeight && h.smoothHeight(a.vars.animationSpeed);
            }
        }, a.wrapup = function(e) {
            // SLIDE:
            p || v || (0 === a.currentSlide && a.animatingTo === a.last && a.vars.animationLoop ? a.setProps(e, "jumpEnd") :a.currentSlide === a.last && 0 === a.animatingTo && a.vars.animationLoop && a.setProps(e, "jumpStart")), 
            a.animating = !1, a.currentSlide = a.animatingTo, // API: after() animation Callback
            a.vars.after(a);
        }, // SLIDESHOW:
        a.animateSlides = function() {
            !a.animating && f && a.flexAnimate(a.getTarget("next"));
        }, // SLIDESHOW:
        a.pause = function() {
            clearInterval(a.animatedSlides), a.animatedSlides = null, a.playing = !1, // PAUSEPLAY:
            a.vars.pausePlay && h.pausePlay.update("play"), // SYNC:
            a.syncExists && h.sync("pause");
        }, // SLIDESHOW:
        a.play = function() {
            a.playing && clearInterval(a.animatedSlides), a.animatedSlides = a.animatedSlides || setInterval(a.animateSlides, a.vars.slideshowSpeed), 
            a.started = a.playing = !0, // PAUSEPLAY:
            a.vars.pausePlay && h.pausePlay.update("pause"), // SYNC:
            a.syncExists && h.sync("play");
        }, // STOP:
        a.stop = function() {
            a.pause(), a.stopped = !0;
        }, a.canAdvance = function(e, t) {
            // ASNAV:
            var n = m ? a.pagingCount - 1 :a.last;
            return t ? !0 :m && a.currentItem === a.count - 1 && 0 === e && "prev" === a.direction ? !0 :m && 0 === a.currentItem && e === a.pagingCount - 1 && "next" !== a.direction ? !1 :e !== a.currentSlide || m ? a.vars.animationLoop ? !0 :a.atEnd && 0 === a.currentSlide && e === n && "next" !== a.direction ? !1 :a.atEnd && a.currentSlide === n && 0 === e && "next" === a.direction ? !1 :!0 :!1;
        }, a.getTarget = function(e) {
            return a.direction = e, "next" === e ? a.currentSlide === a.last ? 0 :a.currentSlide + 1 :0 === a.currentSlide ? a.last :a.currentSlide - 1;
        }, // SLIDE:
        a.setProps = function(e, t, n) {
            var i = function() {
                var n = e ? e :(a.itemW + a.vars.itemMargin) * a.move * a.animatingTo, i = function() {
                    if (v) return "setTouch" === t ? e :d && a.animatingTo === a.last ? 0 :d ? a.limit - (a.itemW + a.vars.itemMargin) * a.move * a.animatingTo :a.animatingTo === a.last ? a.limit :n;
                    switch (t) {
                      case "setTotal":
                        return d ? (a.count - 1 - a.currentSlide + a.cloneOffset) * e :(a.currentSlide + a.cloneOffset) * e;

                      case "setTouch":
                        return d ? e :e;

                      case "jumpEnd":
                        return d ? e :a.count * e;

                      case "jumpStart":
                        return d ? a.count * e :e;

                      default:
                        return e;
                    }
                }();
                return -1 * i + "px";
            }();
            a.transitions && (i = u ? "translate3d(0," + i + ",0)" :"translate3d(" + i + ",0,0)", 
            n = void 0 !== n ? n / 1e3 + "s" :"0s", a.container.css("-" + a.pfx + "-transition-duration", n)), 
            a.args[a.prop] = i, (a.transitions || void 0 === n) && a.container.css(a.args);
        }, a.setup = function(t) {
            // SLIDE:
            if (p) // FADE:
            a.slides.css({
                width:"100%",
                "float":"left",
                marginRight:"-100%",
                position:"relative"
            }), "init" === t && (r ? a.slides.css({
                opacity:0,
                display:"block",
                webkitTransition:"opacity " + a.vars.animationSpeed / 1e3 + "s ease",
                zIndex:1
            }).eq(a.currentSlide).css({
                opacity:1,
                zIndex:2
            }) ://slider.slides.eq(slider.currentSlide).fadeIn(slider.vars.animationSpeed, slider.vars.easing);
            a.slides.css({
                opacity:0,
                display:"block",
                zIndex:1
            }).eq(a.currentSlide).css({
                zIndex:2
            }).animate({
                opacity:1
            }, a.vars.animationSpeed, a.vars.easing)), // SMOOTH HEIGHT:
            a.vars.smoothHeight && h.smoothHeight(); else {
                var n, i;
                "init" === t && (a.viewport = e('<div class="' + s + 'viewport"></div>').css({
                    overflow:"hidden",
                    position:"relative"
                }).appendTo(a).append(a.container), // INFINITE LOOP:
                a.cloneCount = 0, a.cloneOffset = 0, // REVERSE:
                d && (i = e.makeArray(a.slides).reverse(), a.slides = e(i), a.container.empty().append(a.slides))), 
                // INFINITE LOOP && !CAROUSEL:
                a.vars.animationLoop && !v && (a.cloneCount = 2, a.cloneOffset = 1, // clear out old clones
                "init" !== t && a.container.find(".clone").remove(), a.container.append(a.slides.first().clone().addClass("clone").attr("aria-hidden", "true")).prepend(a.slides.last().clone().addClass("clone").attr("aria-hidden", "true"))), 
                a.newSlides = e(a.vars.selector, a), n = d ? a.count - 1 - a.currentSlide + a.cloneOffset :a.currentSlide + a.cloneOffset, 
                // VERTICAL:
                u && !v ? (a.container.height(200 * (a.count + a.cloneCount) + "%").css("position", "absolute").width("100%"), 
                setTimeout(function() {
                    a.newSlides.css({
                        display:"block"
                    }), a.doMath(), a.viewport.height(a.h), a.setProps(n * a.h, "init");
                }, "init" === t ? 100 :0)) :(a.container.width(200 * (a.count + a.cloneCount) + "%"), 
                a.setProps(n * a.computedW, "init"), setTimeout(function() {
                    a.doMath(), a.newSlides.css({
                        width:a.computedW,
                        "float":"left",
                        display:"block"
                    }), // SMOOTH HEIGHT:
                    a.vars.smoothHeight && h.smoothHeight();
                }, "init" === t ? 100 :0));
            }
            // !CAROUSEL:
            // CANDIDATE: active slide
            v || a.slides.removeClass(s + "active-slide").eq(a.currentSlide).addClass(s + "active-slide");
        }, a.doMath = function() {
            var e = a.slides.first(), t = a.vars.itemMargin, n = a.vars.minItems, i = a.vars.maxItems;
            a.w = void 0 === a.viewport ? a.width() :a.viewport.width(), a.h = e.height(), a.boxPadding = e.outerWidth() - e.width(), 
            // CAROUSEL:
            v ? (a.itemT = a.vars.itemWidth + t, a.minW = n ? n * a.itemT :a.w, a.maxW = i ? i * a.itemT - t :a.w, 
            a.itemW = a.minW > a.w ? (a.w - t * (n - 1)) / n :a.maxW < a.w ? (a.w - t * (i - 1)) / i :a.vars.itemWidth > a.w ? a.w :a.vars.itemWidth, 
            a.visible = Math.floor(a.w / a.itemW), a.move = a.vars.move > 0 && a.vars.move < a.visible ? a.vars.move :a.visible, 
            a.pagingCount = Math.ceil((a.count - a.visible) / a.move + 1), a.last = a.pagingCount - 1, 
            a.limit = 1 === a.pagingCount ? 0 :a.vars.itemWidth > a.w ? a.itemW * (a.count - 1) + t * (a.count - 1) :(a.itemW + t) * a.count - a.w - t) :(a.itemW = a.w, 
            a.pagingCount = a.count, a.last = a.count - 1), a.computedW = a.itemW - a.boxPadding;
        }, a.update = function(e, t) {
            a.doMath(), // update currentSlide and slider.animatingTo if necessary
            v || (e < a.currentSlide ? a.currentSlide += 1 :e <= a.currentSlide && 0 !== e && (a.currentSlide -= 1), 
            a.animatingTo = a.currentSlide), // update controlNav
            a.vars.controlNav && !a.manualControls && ("add" === t && !v || a.pagingCount > a.controlNav.length ? h.controlNav.update("add") :("remove" === t && !v || a.pagingCount < a.controlNav.length) && (v && a.currentSlide > a.last && (a.currentSlide -= 1, 
            a.animatingTo -= 1), h.controlNav.update("remove", a.last))), // update directionNav
            a.vars.directionNav && h.directionNav.update();
        }, a.addSlide = function(t, n) {
            var i = e(t);
            a.count += 1, a.last = a.count - 1, // append new slide
            u && d ? void 0 !== n ? a.slides.eq(a.count - n).after(i) :a.container.prepend(i) :void 0 !== n ? a.slides.eq(n).before(i) :a.container.append(i), 
            // update currentSlide, animatingTo, controlNav, and directionNav
            a.update(n, "add"), // update slider.slides
            a.slides = e(a.vars.selector + ":not(.clone)", a), // re-setup the slider to accomdate new slide
            a.setup(), //FlexSlider: added() Callback
            a.vars.added(a);
        }, a.removeSlide = function(t) {
            var n = isNaN(t) ? a.slides.index(e(t)) :t;
            // update count
            a.count -= 1, a.last = a.count - 1, // remove slide
            isNaN(t) ? e(t, a.slides).remove() :u && d ? a.slides.eq(a.last).remove() :a.slides.eq(t).remove(), 
            // update currentSlide, animatingTo, controlNav, and directionNav
            a.doMath(), a.update(n, "remove"), // update slider.slides
            a.slides = e(a.vars.selector + ":not(.clone)", a), // re-setup the slider to accomdate new slide
            a.setup(), // FlexSlider: removed() Callback
            a.vars.removed(a);
        }, //FlexSlider: Initialize
        h.init();
    }, // Ensure the slider isn't focussed if the window loses focus.
    e(window).blur(function() {
        focused = !1;
    }).focus(function() {
        focused = !0;
    }), //FlexSlider: Default Settings
    e.flexslider.defaults = {
        namespace:"flex-",
        //{NEW} String: Prefix string attached to the class of every element generated by the plugin
        selector:".slides > li",
        //{NEW} Selector: Must match a simple pattern. '{container} > {slide}' -- Ignore pattern at your own peril
        animation:"fade",
        //String: Select your animation type, "fade" or "slide"
        easing:"swing",
        //{NEW} String: Determines the easing method used in jQuery transitions. jQuery easing plugin is supported!
        direction:"horizontal",
        //String: Select the sliding direction, "horizontal" or "vertical"
        reverse:!1,
        //{NEW} Boolean: Reverse the animation direction
        animationLoop:!0,
        //Boolean: Should the animation loop? If false, directionNav will received "disable" classes at either end
        smoothHeight:!1,
        //{NEW} Boolean: Allow height of the slider to animate smoothly in horizontal mode
        startAt:0,
        //Integer: The slide that the slider should start on. Array notation (0 = first slide)
        slideshow:!0,
        //Boolean: Animate slider automatically
        slideshowSpeed:7e3,
        //Integer: Set the speed of the slideshow cycling, in milliseconds
        animationSpeed:600,
        //Integer: Set the speed of animations, in milliseconds
        initDelay:0,
        //{NEW} Integer: Set an initialization delay, in milliseconds
        randomize:!1,
        //Boolean: Randomize slide order
        thumbCaptions:!1,
        //Boolean: Whether or not to put captions on thumbnails when using the "thumbnails" controlNav.
        // Usability features
        pauseOnAction:!0,
        //Boolean: Pause the slideshow when interacting with control elements, highly recommended.
        pauseOnHover:!1,
        //Boolean: Pause the slideshow when hovering over slider, then resume when no longer hovering
        pauseInvisible:!0,
        //{NEW} Boolean: Pause the slideshow when tab is invisible, resume when visible. Provides better UX, lower CPU usage.
        useCSS:!0,
        //{NEW} Boolean: Slider will use CSS3 transitions if available
        touch:!0,
        //{NEW} Boolean: Allow touch swipe navigation of the slider on touch-enabled devices
        video:!1,
        //{NEW} Boolean: If using video in the slider, will prevent CSS3 3D Transforms to avoid graphical glitches
        // Primary Controls
        controlNav:!0,
        //Boolean: Create navigation for paging control of each clide? Note: Leave true for manualControls usage
        directionNav:!0,
        //Boolean: Create navigation for previous/next navigation? (true/false)
        prevText:"",
        //String: Set the text for the "previous" directionNav item
        nextText:"",
        //String: Set the text for the "next" directionNav item
        // Secondary Navigation
        keyboard:!0,
        //Boolean: Allow slider navigating via keyboard left/right keys
        multipleKeyboard:!1,
        //{NEW} Boolean: Allow keyboard navigation to affect multiple sliders. Default behavior cuts out keyboard navigation with more than one slider present.
        mousewheel:!1,
        //{UPDATED} Boolean: Requires jquery.mousewheel.js (https://github.com/brandonaaron/jquery-mousewheel) - Allows slider navigating via mousewheel
        pausePlay:!1,
        //Boolean: Create pause/play dynamic element
        pauseText:"Pause",
        //String: Set the text for the "pause" pausePlay item
        playText:"Play",
        //String: Set the text for the "play" pausePlay item
        // Special properties
        controlsContainer:"",
        //{UPDATED} jQuery Object/Selector: Declare which container the navigation elements should be appended too. Default container is the FlexSlider element. Example use would be $(".flexslider-container"). Property is ignored if given element is not found.
        manualControls:"",
        //{UPDATED} jQuery Object/Selector: Declare custom control navigation. Examples would be $(".flex-control-nav li") or "#tabs-nav li img", etc. The number of elements in your controlNav should match the number of slides/tabs.
        sync:"",
        //{NEW} Selector: Mirror the actions performed on this slider with another slider. Use with care.
        asNavFor:"",
        //{NEW} Selector: Internal property exposed for turning the slider into a thumbnail navigation for another slider
        // Carousel Options
        itemWidth:0,
        //{NEW} Integer: Box-model width of individual carousel items, including horizontal borders and padding.
        itemMargin:0,
        //{NEW} Integer: Margin between carousel items.
        minItems:1,
        //{NEW} Integer: Minimum number of carousel items that should be visible. Items will resize fluidly when below this.
        maxItems:0,
        //{NEW} Integer: Maxmimum number of carousel items that should be visible. Items will resize fluidly when above this limit.
        move:0,
        //{NEW} Integer: Number of carousel items that should move on animation. If 0, slider will move all visible items.
        allowOneSlide:!0,
        //{NEW} Boolean: Whether or not to allow a slider comprised of a single slide
        // Callback API
        start:function() {},
        //Callback: function(slider) - Fires when the slider loads the first slide
        before:function() {},
        //Callback: function(slider) - Fires asynchronously with each slider animation
        after:function() {},
        //Callback: function(slider) - Fires after each slider animation completes
        end:function() {},
        //Callback: function(slider) - Fires when the slider reaches the last slide (asynchronous)
        added:function() {},
        //{NEW} Callback: function(slider) - Fires after a slide is added
        removed:function() {}
    }, //FlexSlider: Plugin Function
    e.fn.flexslider = function(t) {
        if (void 0 === t && (t = {}), "object" == typeof t) return this.each(function() {
            var n = e(this), a = t.selector ? t.selector :".slides > li", i = n.find(a);
            1 === i.length && t.allowOneSlide === !0 || 0 === i.length ? (i.fadeIn(400), t.start && t.start(n)) :void 0 === n.data("flexslider") && new e.flexslider(this, t);
        });
        // Helper strings to quickly perform functions on the slider
        var n = e(this).data("flexslider");
        switch (t) {
          case "play":
            n.play();
            break;

          case "pause":
            n.pause();
            break;

          case "stop":
            n.stop();
            break;

          case "next":
            n.flexAnimate(n.getTarget("next"), !0);
            break;

          case "prev":
          case "previous":
            n.flexAnimate(n.getTarget("prev"), !0);
            break;

          default:
            "number" == typeof t && n.flexAnimate(t, !0);
        }
    };
}(jQuery), /*! responsive-nav.js 1.0.23
 * https://github.com/viljamis/responsive-nav.js
 * http://responsive-nav.com
 *
 * Copyright (c) 2013 @viljamis
 * Available under the MIT license
 */
function() {
    "use strict";
    /* exported responsiveNav */
    var e = function(e, t) {
        var n = !!window.getComputedStyle;
        // getComputedStyle polyfill
        n || (window.getComputedStyle = function(e) {
            return this.el = e, this.getPropertyValue = function(t) {
                var n = /(\-([a-z]){1})/g;
                return "float" === t && (t = "styleFloat"), n.test(t) && (t = t.replace(n, function() {
                    return arguments[2].toUpperCase();
                })), e.currentStyle[t] ? e.currentStyle[t] :null;
            }, this;
        });
        /* exported addEvent, removeEvent, getChildren, setAttributes, addClass, removeClass */
        // fn arg can be an object or a function, thanks to handleEvent
        // read more at: http://www.thecssninja.com/javascript/handleevent
        var a, i, s, o, r, l = function(e, t, n, a) {
            if ("addEventListener" in e) // BBOS6 doesn't support handleEvent, catch and polyfill
            try {
                e.addEventListener(t, n, a);
            } catch (i) {
                if ("object" != typeof n || !n.handleEvent) throw i;
                e.addEventListener(t, function(e) {
                    // Bind fn as this and set first arg as event object
                    n.handleEvent.call(n, e);
                }, a);
            } else "attachEvent" in e && (// check if the callback is an object and contains handleEvent
            "object" == typeof n && n.handleEvent ? e.attachEvent("on" + t, function() {
                // Bind fn as this
                n.handleEvent.call(n);
            }) :e.attachEvent("on" + t, n));
        }, c = function(e, t, n, a) {
            if ("removeEventListener" in e) try {
                e.removeEventListener(t, n, a);
            } catch (i) {
                if ("object" != typeof n || !n.handleEvent) throw i;
                e.removeEventListener(t, function(e) {
                    n.handleEvent.call(n, e);
                }, a);
            } else "detachEvent" in e && ("object" == typeof n && n.handleEvent ? e.detachEvent("on" + t, function() {
                n.handleEvent.call(n);
            }) :e.detachEvent("on" + t, n));
        }, u = function(e) {
            if (e.children.length < 1) throw new Error("The Nav container has no containing elements");
            // Loop through children and store in array if child != TextNode
            for (var t = [], n = 0; n < e.children.length; n++) 1 === e.children[n].nodeType && t.push(e.children[n]);
            return t;
        }, d = function(e, t) {
            for (var n in t) e.setAttribute(n, t[n]);
        }, v = function(e, t) {
            0 !== e.className.indexOf(t) && (e.className += " " + t, e.className = e.className.replace(/(^\s*)|(\s*$)/g, ""));
        }, p = function(e, t) {
            var n = new RegExp("(\\s|^)" + t + "(\\s|$)");
            e.className = e.className.replace(n, " ").replace(/(^\s*)|(\s*$)/g, "");
        }, m = document.createElement("style"), h = function(e, t) {
            var n;
            // Default options
            this.options = {
                animate:!0,
                // Boolean: Use CSS3 transitions, true or false
                transition:250,
                // Integer: Speed of the transition, in milliseconds
                label:"Menu",
                // String: Label for the navigation toggle
                insert:"after",
                // String: Insert the toggle before or after the navigation
                customToggle:"",
                // Selector: Specify the ID of a custom toggle
                openPos:"relative",
                // String: Position of the opened nav, relative or static
                jsClass:"js",
                // String: 'JS enabled' class which is added to <html> el
                init:function() {},
                // Function: Init callback
                open:function() {},
                // Function: Open callback
                close:function() {}
            };
            // User defined options
            for (n in t) this.options[n] = t[n];
            if (// Adds "js" class for <html>
            v(document.documentElement, this.options.jsClass), // Wrapper
            this.wrapperEl = e.replace("#", ""), document.getElementById(this.wrapperEl)) this.wrapper = document.getElementById(this.wrapperEl); else {
                if (!document.querySelector(this.wrapperEl)) // If el doesn't exists, stop here.
                throw new Error("The nav element you are trying to select doesn't exist");
                this.wrapper = document.querySelector(this.wrapperEl);
            }
            // Inner wrapper
            this.wrapper.inner = u(this.wrapper), // For minification
            i = this.options, a = this.wrapper, // Init
            this._init(this);
        };
        return h.prototype = {
            // Public methods
            destroy:function() {
                this._removeStyles(), p(a, "closed"), p(a, "opened"), p(a, "nav-collapse"), a.removeAttribute("style"), 
                a.removeAttribute("aria-hidden"), a = null, c(window, "resize", this, !1), c(document.body, "touchmove", this, !1), 
                c(s, "touchstart", this, !1), c(s, "touchend", this, !1), c(s, "mouseup", this, !1), 
                c(s, "keyup", this, !1), c(s, "click", this, !1), i.customToggle ? s.removeAttribute("aria-hidden") :s.parentNode.removeChild(s);
            },
            toggle:function() {
                o === !0 && (r ? (p(a, "opened"), v(a, "closed"), d(a, {
                    "aria-hidden":"true"
                }), i.animate ? (o = !1, setTimeout(function() {
                    a.style.position = "absolute", o = !0;
                }, i.transition + 10)) :a.style.position = "absolute", r = !1, i.close()) :(p(a, "closed"), 
                v(a, "opened"), a.style.position = i.openPos, d(a, {
                    "aria-hidden":"false"
                }), r = !0, i.open()));
            },
            resize:function() {
                "none" !== window.getComputedStyle(s, null).getPropertyValue("display") ? (d(s, {
                    "aria-hidden":"false"
                }), // If the navigation is hidden
                a.className.match(/(^|\s)closed(\s|$)/) && (d(a, {
                    "aria-hidden":"true"
                }), a.style.position = "absolute"), this._createStyles(), this._calcHeight()) :(d(s, {
                    "aria-hidden":"true"
                }), d(a, {
                    "aria-hidden":"false"
                }), a.style.position = i.openPos, this._removeStyles());
            },
            handleEvent:function(e) {
                var t = e || window.event;
                switch (t.type) {
                  case "touchstart":
                    this._onTouchStart(t);
                    break;

                  case "touchmove":
                    this._onTouchMove(t);
                    break;

                  case "touchend":
                  case "mouseup":
                    this._onTouchEnd(t);
                    break;

                  case "click":
                    this._preventDefault(t);
                    break;

                  case "keyup":
                    this._onKeyUp(t);
                    break;

                  case "resize":
                    this.resize(t);
                }
            },
            // Private methods
            _init:function() {
                v(a, "nav-collapse"), v(a, "closed"), o = !0, r = !1, this._createToggle(), this._transitions(), 
                this.resize();
                // IE8 hack
                var e = this;
                setTimeout(function() {
                    e.resize();
                }, 20), l(window, "resize", this, !1), l(document.body, "touchmove", this, !1), 
                l(s, "touchstart", this, !1), l(s, "touchend", this, !1), l(s, "mouseup", this, !1), 
                l(s, "keyup", this, !1), l(s, "click", this, !1), // Init callback
                i.init();
            },
            _createStyles:function() {
                m.parentNode || (m.type = "text/css", document.getElementsByTagName("head")[0].appendChild(m));
            },
            _removeStyles:function() {
                m.parentNode && m.parentNode.removeChild(m);
            },
            _createToggle:function() {
                if (i.customToggle) {
                    var e = i.customToggle.replace("#", "");
                    if (document.getElementById(e)) s = document.getElementById(e); else {
                        if (!document.querySelector(e)) throw new Error("The custom nav toggle you are trying to select doesn't exist");
                        s = document.querySelector(e);
                    }
                } else {
                    var t = document.createElement("a");
                    t.innerHTML = i.label, d(t, {
                        href:"#",
                        "class":"nav-toggle"
                    }), "after" === i.insert ? a.parentNode.insertBefore(t, a.nextSibling) :a.parentNode.insertBefore(t, a), 
                    s = t;
                }
            },
            _preventDefault:function(e) {
                e.preventDefault ? (e.preventDefault(), e.stopPropagation()) :e.returnValue = !1;
            },
            _onTouchStart:function(e) {
                e.stopPropagation(), this.startX = e.touches[0].clientX, this.startY = e.touches[0].clientY, 
                this.touchHasMoved = !1, c(s, "mouseup", this, !1);
            },
            _onTouchMove:function(e) {
                (Math.abs(e.touches[0].clientX - this.startX) > 10 || Math.abs(e.touches[0].clientY - this.startY) > 10) && (this.touchHasMoved = !0);
            },
            _onTouchEnd:function(e) {
                if (this._preventDefault(e), !this.touchHasMoved) {
                    if ("touchend" === e.type) {
                        this.toggle(e);
                        // Prevent click on the underlying menu on Android 2.3
                        var t = this;
                        return a.addEventListener("click", t._preventDefault, !0), setTimeout(function() {
                            a.removeEventListener("click", t._preventDefault, !0);
                        }, i.transition + 100), void 0;
                    }
                    var n = e || window.event;
                    // If it isn't a right click
                    3 !== n.which && 2 !== n.button && this.toggle(e);
                }
            },
            _onKeyUp:function(e) {
                var t = e || window.event;
                13 === t.keyCode && this.toggle(e);
            },
            _transitions:function() {
                if (i.animate) {
                    var e = a.style, t = "max-height " + i.transition + "ms";
                    e.WebkitTransition = t, e.MozTransition = t, e.OTransition = t, e.transition = t;
                }
            },
            _calcHeight:function() {
                for (var e = 0, t = 0; t < a.inner.length; t++) e += a.inner[t].offsetHeight;
                var n = ".nav-collapse.opened{max-height:" + e + "px}";
                m.styleSheet ? m.styleSheet.cssText = n :m.innerHTML = n, n = "";
            }
        }, new h(e, t);
    };
    window.responsiveNav = e;
}();